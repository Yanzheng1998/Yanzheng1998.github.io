---
title: 'Database Review'
date: 2020-03-24
permalink: /posts/2020/03/blog-post-2/
tags:
  - cool posts
  - category1
  - category2
---

Database FAQ


# 数据库

<a name="2Tqsi"></a>
# 事物的基本要素
- 原子性:
  - 事务开始后所有操作,要么全部完成,要么全部不完成.
- 一致性
  - 事务开始前后,数据库的完整性约束没有被破坏.
- 隔离线
  - 同一时间只允许一个事务请求同一个数据
- 持久性
<a name="Bo5Mi"></a>
# MySql日志

- redo log
  - 前滚
  - 记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。
  - 为了保证持久性，必须在事务提交前将RedoLog持久化。
  - 数据不需要在事务提交前写入磁盘，而是缓存在内存中。
  - RedoLog保证事务的持久性。
  - RedoLog保证事务的持久性。
- undo log
  - 在储存引擎中
  - 回滚
  - 满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方
  - 然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用UndoLog中的备份将数据恢复到事务开始之前的状态。
  - 缺点
    - **每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br />如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo log**
- binlog
  - 记录所有更新且提交了数据或者已经潜在更新提交了数据（例如，没有匹配任何行的一个DELETE）的所有语句
  - 作用
    - 恢复是能够最大可能地更新数据库
    - 在主复制服务器上记录地所有将发送给从服务器地语句
    - Undo log必须先于数据持久化到磁盘, 这样如果在数据持久化和提交前甭困
<a name="Fuaxk"></a>
# 如何解决事务并发

- 可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。
- 当前事务内的更新，可以读到；

版本未提交，不能读到；<br />版本已提交，但是却在快照创建后提交的，不能读到；<br />版本已提交，且是在快照创建前提交的，可以读到；
<a name="80e8p"></a>
# 为什么要索引

- 创建唯一索引, 可以保证数据库表中每一行数据的唯一性
- 加快数据库的检索能力
- 避免排序和临时表
- 随机IO变为顺序IO
- 加速表与表之间的链接
<a name="Cqer1"></a>
# Mysql索引的两种数据结构

- 哈希
- B Tree
  - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1378916/1588726514913-b2aaeeba-4a50-4137-85bc-ee27a9bf7eb7.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=624&size=194006&status=done&style=none&width=624)
- B+Tree
  - B+树索引并不能找到一个给定值的具体行，B+树索引能找到的只是查找数据行所在的页。然后数据库通过把数据页读入内存，再在内存中进行查找，最后得到查找的数据。
- B树和B+树
  - B+-tree的内部节点并没有指向关键字具体信息的指针，换句话说，即分支节点没有存储数据，因此其内部节点相对B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读内存中的需要查找的关键字也就越多。相对来说**IO读写次数也就降低**了。
  - **B+树的查询效率更加稳定:**在B+树中，由于分支节点并不是最终指向文件内容的节点，分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每个数据查询效率相当。而对于B树而言，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，效率也不一样。
  - 由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了**B树元素遍历效率低下**的问题
  - B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。
  - MyISAM
    - B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
    - 索引文件仅保存记录所在页的指针
  - InnoDB
    - 数据文件本身就是索引文件
- 最左前缀
  - 联合索引
  - 创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。
<a name="ZPRRJ"></a>
# MySQL的引擎

- InnoDB
  - 支持行锁定和外键
  - MVCC多版本储存
    - B+Tree叶结点上，始终存储的是最新的数据（可能是还未提交的数据）。而旧版本数据，通过UNDO记录（做DELTA）存储在回滚段（Rollback Segment）里。每一条记录都会维护一个ROW HEADER元信息，存储有创建这条记录的事务ID，一个指向UNDO记录的指针。通过最新记录和UNDO信息，可以还原出旧版本的记录。
    - 快照
```
ReadView {
    creator_trx_id //创建这个ReadView的事务ID
    low_limit_id //所有事务ID大于或等于low_limit_id对当前事务都不可见
    up_limit_id //所有事务ID严格小于up_limit_id的事务对当前事务可见
    ids //未提交的事务ID列表
    ...
}
IsVisible(trx_id)
    if (trx_id == creator_trx_id)     // 当前事务
        return true;
    else if (trx_id < up_limit_id)    // ReadView创建时, 事务已提交
        return true;
    else if (trx_id >= low_limit_id)  // ReadView创建时，事务还未被创建
        return false;
    else if (trx_id is in m_ids)  // ReadView创建时，事务正在执行，但未提交
        return false
    else                          // ReadView创建时, 事务已提交
        return true;
```

<br />

