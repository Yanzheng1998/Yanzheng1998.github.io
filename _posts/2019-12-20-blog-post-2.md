---
title: 'Operating System Review'
date: 2019-12-20
permalink: /posts/2019/12/blog-post-1/
tags:
  - cool posts
  - category1
  - category2
---

Operating Systems FAQ


<a name="sZiVs"></a>
# 基础
<a name="PRwDE"></a>
## 什么是操作系统

- 管理计算机硬件和软件资源
- 为用户提供与系统的交互
- 分为内核与外壳



<a name="QE8HG"></a>
## 系统调用

- 用户态
- 内核态
  - 可以访问计算机的任何资源



<a name="r7OFl"></a>
# 进程与线程
<a name="zNHQN"></a>
## 进程与线程的区别

- 一个进程中可以有多个线程
- 线程私有
  - 程序计数器
  - 栈
- 进程间相对独立
  - 利于资源管理
<a name="m2JnW"></a>
## 进程状态

- 创建状态
  - 正在被创建
- 就绪状态
  - 拥有除CPU以外的所有资源
- 运行状态
- 阻塞状态
  - 等待某一件事而暂停
- 结束状态
<a name="Y03EX"></a>
## 线程状态

- 创建
- 就绪
- 运行
- 阻塞
- 等待
  - wait() 让出CPU资源和锁资源
  - sleep() 不让出锁资源
- 时间等待
- 消亡
- 等待和阻塞的区别
  - block等锁
  - wait等待唤醒
- ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1378916/1588636105313-d9410df9-e0a9-450b-abd4-54d56edcc774.png#align=left&display=inline&height=531&margin=%5Bobject%20Object%5D&name=image.png&originHeight=531&originWidth=778&size=219970&status=done&style=none&width=778)
<a name="nBH2h"></a>
## 进程间通信

- 管道
  - 具有亲缘关系的父子进程和兄弟之前通信
  - 单向
  - 本质是一块特殊的内存文件
  - 先进先出
- 有名管道
  - 任意进程间通信
  - 磁盘文件
- 信号
  - 用于通知接受某个事件
  - SIGALRM
  - SIGHUP
  - SIGINT(ctrl+c)
  - int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
- 消息队列
  - 放在内核中
  - 发送数据块, 含有类型
  - 避免命名管道的同步和阻塞问题
  - 独立与发送和接受进程存在
  - 根据消息类型有选择的接受
- 信号量
  - 用于多进程对共享数据的访问
  - 进程间同步
  - P(sv):  如果sv的值大于0, 执行进程, 并使sv - 1; 如果sv等于0, 挂起进程并等待
  - V(sv): 如果有其他进程等待,则恢复其他进程; 如果没有,则sv + 1;
- 共享内存
  - 需要信号量来同步
- 套接字
  - 流套接字
    - TCP
  - 数据报套接字
    - UDP
<a name="Pindi"></a>
## 线程间同步

- 互斥量
  - java 的 sychronized 和 lock
- 信号量
- 事件
  - 通过通知来保持同步, 实现多线程优先级的比较
<a name="ip1d3"></a>
## 调度算法

- 先到先服务
- 短作业优先
- 时间片轮转
- 多级反馈队列
- 优先级调度
<a name="ISMWT"></a>
## 什么是死锁

- 死锁的概念
  - 多个进程无限期的阻塞,相互等待
- 四个条件
  - 互斥
    - 至少有一个资源必须属于非分享模式
  - 占有并等待
    - 一个进程必须占有至少一个资源并等待另一个资源,而该资源为其他进程所占有
  - 非抢占
    - 进程不能被抢占
  - 循环等待
    - 若干进程之间形成一种头尾详解的环形等待资源关系
- 死锁的处理
  - 死锁预防
    - 确保四个的条件至少有一个不成立
      - 打破互斥
        - 允许进程同时访问某些资源
      - 打破占有并等待条件
        - 资源预先分配策略
          - 当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程
        - 只允许进程在没有占用资源时才可以申请资源
          - 一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源
        - 缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。
      - 打破非抢占条件
        - 进程强行从占有者哪里夺取某些资源
      - 打破循环等待
        - 资源有序分配策略
          - 对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源
  - 死锁避免
    - 动态地检测资源分配状态,确保循环等待条件不成立
      - 银行家算法
        - ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1378916/1588635067988-361522af-c151-4bea-b2a8-452f3ca172da.png#align=left&display=inline&height=551&margin=%5Bobject%20Object%5D&name=image.png&originHeight=551&originWidth=992&size=60144&status=done&style=none&width=992)
        - 首先是银行家算法中的进程：包含进程Pi的需求资源数量（也是最大需求资源数量，MAX）
        - 已分配给该进程的资源A（Allocation）
        - 还需要的资源数量N（Need=M-A）
        - Available为空闲资源数量，即资源池（注意：资源池的剩余资源数量+已分配给所有进程的资源数量=系统中的资源总量）
        - 假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。
        - 若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–>回收（Work+已分配给P0的A0=Work）–>分配给P3–>回收（Work+A3=Work）–>分配给P2–>······满足所有进程）。
        - 如此就可避免系统存在潜在死锁的风险。
  - 死锁解除
    - 选择一个牺牲品
    - 回滚到安全状态
    - 饥饿(避免一个进程总被回滚)
<a name="GEa05"></a>
# 内存管理
<a name="XogWI"></a>
## 块式管理

- 将内存分为固定大小的块
- 每个块包含一个进程
- 容易产生碎片
<a name="nmkUA"></a>
## 页式管理

- 页表
- 多层页表
- 块表
  - 页表访问多一次
  - 块表存在于硬件缓存中
- 减少了碎片
<a name="RyGBz"></a>
## 段式管理

- 段表



<a name="rsw9P"></a>
## 段页式
<a name="OS4gs"></a>
## 异同

- 共同点
  - 提高内存利用率
  - 都是离散储存的
- 异
  - 段有外碎片;页有内碎片
  - 页的大小是固定的;段的大小不固定
  - 段是逻辑单位;页是物理单位
    - 分段利于信息共享
    - 共享过程需要几十个页面
  - 信息保护
    - 一个页面可能装有2个不同的子程序段的指令代码
  - 段利于动态链接
  - 段表:
    - 段和段是离散的
    - 需要段的基址
  - 页表
    - 页是连续的

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1378916/1588629949014-e81e4eaa-c01f-4fd5-9a2f-7f795fbce881.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=473&size=55079&status=done&style=none&width=473)
<a name="05kvH"></a>
# 页面置换算法

- LRU
- FIFO
- LFU
<a name="b3Fqt"></a>
# 颠簸

- 颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）
<a name="p8f6c"></a>
# 局部性原理

- Temporal locality
- space locality


